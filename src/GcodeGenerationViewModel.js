/*Copyright Todd Fleming, Crawford Currie 2014-2025. This file is part of SVGcut, see the copyright and LICENSE at the root of the distribution. */

// import "knockout"
/* global ko */

/* global App */

import { UnitConverter } from "./UnitConverter.js";
import * as Gcode from "./Gcode.js";
import { CutPath } from "./CutPath.js";
import { CutPaths } from "./CutPaths.js";
import { ViewModel } from "./ViewModel.js";
import * as HoldingTabs from "./HoldingTabs.js";
import { Rect } from "./Rect.js";
import { DEFAULT } from "./Constants.js";

/**
 * ViewModel for Gcode Generation panel.
 * @listens UPDATE_GCODE triggers Gcode generation
 * @extends ViewModel
 */
export class GcodeGenerationViewModel extends ViewModel {

  /**
   * Units used in the Gcode pane, and the generated Gcode
   * @member {observable.<string>}
   */
  units = ko.observable(DEFAULT.GCODE_UNITS);

  /**
   * Flag to lock out gcode generation.
   * @member {boolean}
   */
  disable = false;

  /**
   * Gcode generated by this converter
   * @member {observable.<string[]>}
   */
  gcode = ko.observable([]);

  /**
   * Stringification of the gcode.
   * @member {observable.<string>}
   */
  gcodeS = ko.observable("");

  /**
   * True to return to machine 0,0 at the end of the GCode.
   * @member {observable.<boolean>}
   */
  returnHome = ko.observable(DEFAULT.RETURN_HOME);

  /**
   * Where the origin is one of "SVG page", "Bounding box" or
   * "Centre".
   * In SVG, the origin is at the top left, and Y increases
   * downwards. Internally we use internal coordinates, which follow
   * this pattern. Gcode, on the other hand, assumes Y increases
   * upwards. "SVG page" will align the machine origin with the lower
   * left corner of the SVG page. "Bounding box" will align with the
   * lower left corner of the work bounding box. "Centre" will align
   * with the centre of the work bounding box.
   * @member {observable.<string>}
   */
  origin = ko.observable(DEFAULT.ORIGIN);

  /**
   * Extra offset of the work origin from the machine origin
   * @member{observable.number}
   */
  extraOffsetX = ko.observable(DEFAULT.EXTRA_X);

  /**
   * Extra offset of the work origin from the machine origin
   * @member{observable.number}
   */
  extraOffsetY = ko.observable(DEFAULT.EXTRA_Y);

  /**
   * Width of the work BB, irrespective of the origin.
   * @member {observable.<number>}
   */
  bbWidth = ko.observable(0);

  /**
   * Height of the work BB, irrespective of the origin
   * @member {observable.<number>}
   */
  bbHeight = ko.observable(0);

  /**
   * Note that this view model has it's own unit converter.
   * The gcode generation will generate gcode coordinates in these
   * units. It will also display generation characteristics,
   * such as offsets, in these units.
   */
  constructor() {
    super();

    document.addEventListener("UPDATE_GCODE", () => this.#generateGcode());

    this.unitConverter = new UnitConverter(this.units);

    this.gcode.subscribe(() => {
      this.gcodeS(this.gcode().join("\n"));
      if (this.gcode().length > 0) {
        for (const el of document.querySelectorAll(".gcode-activated"))
          el.classList.remove("disabled");
      } else {
        for (const el of document.querySelectorAll(".gcode-activated"))
          el.classList.add("disabled");
      }
      this.updateGcodeOrigin(this.#originOffset());
    });

    this.returnHome.subscribe(() => {
      document.dispatchEvent(new Event("UPDATE_GCODE"));
      document.dispatchEvent(new Event("PROJECT_CHANGED"));
    });

    this.origin.subscribe(() => {
      document.dispatchEvent(new Event("UPDATE_GCODE"));
      document.dispatchEvent(new Event("PROJECT_CHANGED"));
    });

    /* @todo generate G10,G54 to do this
     * For future reference:
     * G10 defines the coordinates of work offsets G54-G59
     * G10 Pn Xxxx Yxxx Zzzz
     * P1=G54.. P6=G59
     * G54..G59 are 6 possible "blank locations" - offsets for
     * workpieces on the platform, referred to as "datums".
     * Switch the datum using "G54".
     * So to set a new zero point at (7, 12):
     * G10 P1 X7 Y12 Z0
     * G54
     */
    this.extraOffsetX.subscribe(() => {
      document.dispatchEvent(new Event("UPDATE_GCODE"));
      document.dispatchEvent(new Event("PROJECT_CHANGED"));
    });
    this.extraOffsetY.subscribe(() => {
      document.dispatchEvent(new Event("UPDATE_GCODE"));
      document.dispatchEvent(new Event("PROJECT_CHANGED"));
    });

    App.models.Operations.boundingBox.subscribe(
      bb => {
        this.bbWidth(
          this.unitConverter.fromUnits(bb.width, "integer").toFixed(2));
        this.bbHeight(
          this.unitConverter.fromUnits(bb.height, "integer").toFixed(2));
      });

    window.addEventListener("resize", () => this.#fitCanvas());

    document.getElementById("SimulationModal")
    .addEventListener("shown.bs.modal", () => {
      this.#fitCanvas();
    });
  }

  /**
   * @override
   */
  bind() {
    for (const id of [
      "GcodeGenerationView", "ViewGcodeModal", "SimulationModal" ])
      super.bind(id);
  }

  /**
   * @override
   */
  reset() {
    this.units(DEFAULT.GCODE_UNITS);
    this.origin(DEFAULT.ORIGIN);
    this.extraOffsetX(DEFAULT.EXTRA_X);
    this.extraOffsetY(DEFAULT.EXTRA_Y);
    this.returnHome(DEFAULT.RETURN_HOME);
    this.gcode([]);
    document.dispatchEvent(new Event("UPDATE_SIMULATION"));
  }

  /**
   * Update the size of the simulation canvas to match
   * the size of the main SVG.
   */
  #fitCanvas() {
    // Get the whole middle section for width
    const canvas = document.getElementById("SimulationCanvas");
    const min = Math.min(canvas.clientWidth, canvas.clientHeight);
    // Make the simulation square
    App.resizeSimulationCanvas(min, min);
  }

  /**
   * Work out origin offset in Gcode units. This is the offset of the
   * Gcode origin from the *top left* of the bounding box.
   * @return {Rect} the paths BB offset by the origin position
   */
  #originOffset() {
    // Get the SVG bounding box in gcode units, with Y=0 at the top
    const svgBB = this.unitConverter.fromUnits(App.getPageDimensions(), "px");
    let xOffset = svgBB.left + Number(this.extraOffsetX());
    let yOffset = svgBB.bottom - Number(this.extraOffsetY());
    // yOffset is measured from the top of the BB

    // Get the BB of the paths in gcode units, with Y=0 at the top
    const pathsBB = this.unitConverter.fromUnits(
      App.models.Operations.getBounds(), "integer");
    if (this.origin() === "Bounding box" || this.origin() === "Centre") {
      xOffset += (pathsBB.left - svgBB.left);
      yOffset += (pathsBB.bottom - svgBB.bottom);
      if (this.origin() === "Centre") {
        xOffset += pathsBB.width / 2;
        yOffset -= pathsBB.height / 2;
      }
    }
    return new Rect(xOffset, yOffset, pathsBB.width, pathsBB.height);
  }

  /**
   * Generate gcode for the tool paths specified by the selected
   * operations in the Operations card. This will be invoked in
   * response to something raising the UPDATE_GCODE event.
   */
  #generateGcode() {
    if (this.disable)
      return;

    this.gcode([]);

    if (!App.inputsAreValid())
      return;

    // Get the set of enabled operations
    const ops = [];
    for (const op of App.models.Operations.operations()) {
      if (op.enabled()) {
        if (op.toolPaths() && op.toolPaths().length > 0)
          ops.push(op);
      }
    }
    if (ops.length === 0)
      return;

    //console.debug(`generateGcode for ${ops.length} operations`);

    const gunits = this.unitConverter.units();

    // Get enabled tabs
    let tabGeometry = new CutPaths();
    const tabs = App.models.Tabs.tabs();
    const tabsDepth = App.models.Tabs.maxCutDepth.toUnits(gunits);
    for (const tab of tabs) {
      if (tab.enabled()) {
        // Bloat tab geometry by the cutter radius
        const bloat = App.models.Tool.cutterDiameter.toUnits("integer") / 2;
        tabGeometry = tabGeometry.union(tab.getOffsetCombinedGeometry(bloat));
      }
    }

    const offset = this.#originOffset();
    //console.debug("Gcode offset", offset);

    const job = new Gcode.Generator({
      gunits:      gunits,
      // Scaling to apply to internal units in paths, to generate Gcode units.
      xScale:      UnitConverter.from.integer.to[gunits],
      yScale:      -UnitConverter.from.integer.to[gunits],
      zScale:      UnitConverter.from.integer.to[gunits],
      decimal:     2, // 100th mm
      topZ:        App.models.Material.topZ.toUnits(gunits),
      botZ:        App.models.Material.botZ.toUnits(gunits),
      safeZ:       App.models.Material.zSafeMove.toUnits(gunits),
      plungeRate:  App.models.Tool.plungeRate.toUnits(gunits),
      retractRate: App.models.Tool.rapidRate.toUnits(gunits),
      rapidRate:   App.models.Tool.rapidRate.toUnits(gunits),
      returnHome:  this.returnHome(),
      workWidth:   Number(this.bbWidth()),
      workHeight:  Number(this.bbHeight()),
      xOffset:     offset.x,
      yOffset:     offset.y
    });

    if (job.passDepth < 0) {
      App.showAlert("passDepthTooSmall", "alert-warning", job.passDepth);
      // Plough on; we might be behaving as a plotter
      job.passDepth = 0;
    }

    for (const op of ops) {
      const opCard = {
        name:      op.name(),
        cutType:   op.operation(),
        ramp:      op.ramp(),
        passDepth: op.passDepth()
        ? op.passDepth.toUnits(gunits)
        : App.models.Tool.passDepth.toUnits(gunits),
        rpm: op.rpm()
        ? Number(op.rpm())
        : Number(App.models.Tool.rpm()),
        cutRate:   op.cutRate()
        ? op.cutRate.toUnits(gunits)
        : App.models.Tool.cutRate.toUnits(gunits),
        direction: op.direction(),
        precalculatedZ: op.toolpathGenerator.generatesZ
      };

      let paths = op.toolPaths();
      const cutZ = job.topZ - Number(op.cutDepth());
      const tabZ = job.topZ - tabsDepth;

      // tabZ must be > the cutZ depth of the Operation. If it isn't,
      // or Z's were precalculated, then ignore the tab geometry
      let tg = (tabZ <= cutZ || opCard.precalculatedZ)
          ? undefined : tabGeometry;

      let cutPaths = new CutPaths();
      if (opCard.precalculatedZ) {
        cutPaths = cutPaths.concat(paths);
      } else {
        // Split paths over tab geometry and assign Z's where not
        // already defined
        for (const path of paths) {
          cutPaths = cutPaths.concat(
            HoldingTabs.splitPathOverTabs(path, tg, cutZ, tabZ));
        }
      }
      opCard.paths = cutPaths;

      job.addOperation(opCard);
    }

    // Save the gcode to the observable
    this.gcode(job.end());

    //console.debug(`${this.gcode().length} lines of Gcode generated`);

    document.dispatchEvent(new Event("UPDATE_SIMULATION"));

    App.tutorial(4);
  }

  haveGcode() {
    const gc = this.gcode();
    return gc && gc.length > 0;
  }

  /**
   * Update the axes picture for the current gcode. Here because at
   * some point might want to make origins relative to the toolpaths,
   * rather than the entire SVG image.
   */
  updateGcodeOrigin(bb) {
    let w = this.unitConverter.toUnits(bb.width, "px"),
        h = this.unitConverter.toUnits(bb.height, "px"),
        x, y;

    const group = document.getElementById("AxesSVGGroup");
    if (w <= 0 || h <= 0 || !this.haveGcode()) {
      group.setAttribute("visibility", "hidden");
      x = y = w = h = 0;
    } else {
      group.setAttribute("visibility", "visible");
      x = this.unitConverter.toUnits(bb.x, "px");
      y = this.unitConverter.toUnits(bb.y, "px");
    }

    //console.log("UGCO",x, y, w, h);
    const xAxis = document.getElementById("X-Axis");
    const yAxis = document.getElementById("Y-Axis");
    xAxis.setAttribute("x1", x);
    xAxis.setAttribute("y1", y);
    xAxis.setAttribute("x2", x + w / 3);
    xAxis.setAttribute("y2", y);

    yAxis.setAttribute("x1", x);
    yAxis.setAttribute("y1", y);
    yAxis.setAttribute("x2", x);
    yAxis.setAttribute("y2", y - h / 3);
  }

  /**
   * @override
   */
  jsonFieldName() { return 'gcodeConversion'; }

  /**
   * @override
   */
  toJson() {
    return {
      units: this.unitConverter.units(),
      origin: this.origin(),
      returnHome: this.returnHome(),
      extraOffsetX: this.extraOffsetX(),
      extraOffsetY: this.extraOffsetY()
    };
  }

  /**
   * @override
   */
  fromJson(json) {
    this.updateObservable(json, 'units');
    this.updateObservable(json, 'origin');
    this.updateObservable(json, 'returnHome');
    this.updateObservable(json, 'extraOffsetX');
    this.updateObservable(json, 'extraOffsetY');
  };
}

